# MQ相关

 - [为什么要使用消息队列?](#为什么要使用消息队列?)
 
 - [消息队列有什么优点及缺点?](#消息队列有什么优点及缺点?)
 
 - [Kafka、ActiveMQ、RabbitMQ、RocketMQ都有什么区别？以及适应哪些场景](#Kafka与ActiveMQ与RabbitMQ与RocketMQ都有什么区别？以及适应哪些场景)
 
 - [消息堆积](#消息堆积)
 
 - [消息延时、过期失效的问题](#消息延时与过期失效的问题)
 
 ### 为什么要使用消息队列?
 
     解耦:
        解决了不同消息队列的各个系统之间调用的耦合问题.
        事例:一个系统对其他多个系统之间接口调用、去除调用、传不同的参数等，调用之间频繁的修改接口带来的严重耦合问题。
        MQ的Pub/Sub模型(发布订阅模型可以实现解耦)
     异步:
        解决了不同服务调用服务耗时的同步问题及A服务调用B服务(200ms)、调用C服务(400ms)、调用D服务(400ms)的耗时问题。
     削峰:
        避免大量用户调用A服务，A服务大量请求MySQL数据库(2000QPS)，MQ起到了削峰的作用，使请求到达A服务及数据库的请求
        没有那么多，使服务正常运行。   

 ### 消息队列有什么优点及缺点?
     
     优点:
        解耦、异步、削峰
     缺点:
        1、系统可用性降低(MQ服务挂掉的情况会导致的问题)
           如何保证消息队列的高可用性:
                RabbitMQ:
                    镜像集群模式下的MQ(每个节点上都有queue的全部数据)相比普通集群(只有一个节点有queue的全部数据，如果用户
                    请求其他节点必须经过此节点)更加高可用。
                    通过后台管理可以开启一个策略，使每个节点都有queue的全部数据，进而能够开启镜像集群模式。
                    问题不是分布式的(节点的queue的数据量比较大时导致queue存不下来的情况怎么办？)
                Kafka:
                    纯分布式的，数据分担到不同的机器上，有leader和follower进行选举机制(和集群不同的是集群中服务的数据是所有
                    的数据，数据没有分布；而分数式是数据分布到不同的机器上)
        
        2、考虑的问题变多了(消息重发的、消息丢失的情况、消息发送的顺序变了、消息服务挂了导致消息积累问题)        
        3、一致性问题(ABC服务成功而D失败，导致给用户的是成功其实数据是失败的)
            幂等性问题:
                例子:kafka消费者消费数据是有offset提交到zookeeper由zookeeper通知kafka的offset到哪了，但是消费者不是消费
                    完之后立马提交，消费者还没来得及提交就挂了，导致offset没有提交到zookeeper从而导致kafka把数据都推给消费
                    者，导致数据重发。
                那么怎么保证幂等性：
                    一条数据重复出现两次，这时如果数据库中有一条数据那么就能保证数据的幂等性。
                    解决办法:插入前进行校验过滤(如set)去重，数据库的唯一键约束也可以解决问题。
            数据丢失的问题:
                生产者--------网络传输中丢/MQ没有接收-------->MQ(MQ挂掉)-------->消费者(消费消息但是没有处理消费者挂了)              
                生产者丢数据:
                    1、消息异常会回滚，失败重试
                    2、confirm回调机制:
                            生产者发送数据到MQ，如果成功MQ会回调生产者一个回调方法，失败的话会重发消息，一般是用confirm机制
                            因为是异步形式吞吐量比较高。
                RQ弄丢数据:
                    消息持久化到磁盘上，但是还是有问题，MQ已经开启数据持久化机制，消息暂存到内存中还没来得及持久化到磁盘中MQ挂
                    了的情况。(这种机制是没法避免的会存在消息丢失)
                
                消费者丢失数据:
                    消费者打开autoAck机制，如果消费者消费消息并返回给MQ的autoAck说已经消费消息，但是消费者还没处理完此时消费
                    者挂了的情况。
                    解决：
                        可以关闭autoAck自己处理完消息之后返回给MQ为ack，如果消费者一个服务挂了，MQ没有收到ack此时MQ会把消息
                        推送给其他服务去消费消息)
                    kafka数据丢失:
                        一台机器的leader挂掉但是数据还没同步到follower,即使follower切换到leader但是此时也没有数据导致数据
                        丢失。
                        解决：设置ack=all及leader接收消息会同步到follower才认为数据发送服务成功，否则失败重试。
            消息的顺序性问题：
                RabbitMQ:消费者消费数据的顺序不一致的问题.
                         解决:把需要顺序的数据放到一个queue中，这一个queue保证被一个消费者消费。
                Kafka:以订单ID为key放到同一个partition中，然后这个partition被一个消费者消费，但是消费者在多线程中会存在问题
                      (消费者中放入一个内存queue，把相同的partition的数据放到同一个内存queue中)                    
 
 ### Kafka与ActiveMQ与RabbitMQ与RocketMQ都有什么区别？以及适应哪些场景
     
     ActiveMQ:吞吐量比RocketMQ和Kafka较低了一个数量级，高可用。
        优点:比较成熟
        缺点:偶尔丢消息，社区维护少
     
     RabbitMQ:吞吐量比RocketMQ和Kafka较低了一个数量级(单机/普通集群)不是分布式的，适合中小型企业
        优点:ErLang语言开发延时比较低，后台管理界面很完善有监控，社区相对比较活跃。
        缺点:吞吐量相对较小,ErLang语言源码维护比较难
     
     RocketMQ:阿里开源的项目，单机吞吐量比较大、java语言、分布式适合中大型公司
        优点:接口简单、阿里开源吞吐量比较大、高可用、分布式的扩展比较方便，社区活跃度还可以。
        缺点:项目被抛弃的话维护很难(开源社区黄了的话)                      
     
     Kafka:功能少、吞吐量超高、适合大数据实时计算及日志采集、go语言开发、社区活跃度也挺高、分布式适合大数据
 
 ### 消息堆积    
     
     消费者宕机导致MQ消息大量积压:
                            （积压上百万条/千万条）
         生产者-----------------------MQ----------------->消费者
         解决思路:当消费者服务恢复之后之前的(消费者1、消费者2、消费者3)先别落库，把拿到的partition放到一个
                能够容纳更多的partition中是原来的10倍或者更多的临时MQ，然后申请更多的消费者服务去进行落库
                操作，大大提高了执行速度。    
 
 ### 消息延时与过期失效的问题
     RabbitMQ会有过期时间，消息积压在MQ没有处理。
     解决:手动写程序先把丢失的数据查出来，手动发到MQ中进行补偿机制处理。              
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                                        
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
                    
     

> reubenwang@foxmail.com
> 没事别找我，找我也不在！--我很忙🦆