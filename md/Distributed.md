# 分布式相关

 - [分布式系统服务之间的幂等性](#分布式系统服务之间的幂等性)
 
 - [分布式系统之间如何保证顺序性](#分布式系统之间如何保证顺序性)
 
 - [分布式锁](#分布式锁)
 
 ### 分布式系统服务之间的幂等性
 
     浏览器发两次订单支付请求：
        1、单机用set去重
        2、多台机器之间怎么保证，这就是分布式系统的幂等性问题
           由于网络请求，浏览器发送第一次请求已经发了，但是由于网络原因一直没有响应，此时浏览器以为失败了就会再次发送一
           条请求，导致重复请求的问题。
        经验：
           1、用数据库的唯一键
           2、基于redis把order_id为key，set进去并置为一个状态，假如为已支付状态则不能再次set
             
 ### 分布式系统之间如何保证顺序性
 
     服务之间请求按照顺序执行
        1、可以基于dubbo的一致性hash策略模式,引入一个中间服务把order_id相同的请求按顺序分发到同一台服务A中，然后把请
           求按照一致性hash策略放到同一个队列中，即使是多线程也能保证只有一个线程执行。
        2、zookeeper分布式锁
             order_id+seq(序号)
             当执行的时候先拿到锁，然后看订单对应的序号，如果刚开始序号不是1那么就释放锁，下一个请求获取锁，意思就是根
             据序号来判定执行顺序。       
 
 ### 分布式锁
 
     redis分布式锁：
       1、普通实现：
          set orderId:1:lock 随机值 NX PX 30000
          释放锁通过lua脚本会判断一下orderId:1:lock及key的随机值，如果随机值不一致则不能删除
          问题：
             单机的话挂了就完了。
             主备也会存在分布式锁失败的问题（当master宕了还没来得及切换到slave就会导致事务不一致问题）
       2、RedLock算法
          redis cluster集群模式
          多个master分别获取锁，大多数node节点获取锁的时候才能针对某一个进行加锁，保证了即使宕机也会保证数据的一致性。
     zookeeper分布式锁：
          获取锁的时候就会创建临时节点，如果这个临时节点之前不存在那么就创建成功了，zookeeper保证只有一个人可以获取到
          同一把锁，其他机器尝试创建临时节点此时如果临时节点存在则创建失败，那么就会对那个临时节点注册一个监听器，如果
          这个临时节点的锁被释放了及第一个服务宕了此临时节点被zookeeper删除了，那么zookeeper就会通知此服务的然后此服
          务就会获取临时节点。
     对比：
        redis锁依赖与集群，每个一段时间尝试获取锁造成性能开销
        zookeeper是通过消息监听的方式，相对redis分布式锁要好
> reubenwang@foxmail.com
> 没事别找我，找我也不在！--我很忙🦆