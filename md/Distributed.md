# 分布式相关

 - [分布式系统服务之间的幂等性](#分布式系统服务之间的幂等性)
 
 - [分布式系统之间如何保证顺序性](#分布式系统之间如何保证顺序性)
 
 - [分布式锁](#分布式锁)
 
 - [分布式session](#分布式session)
 
 = [分布式事务](#分布式事务)
 
 ### 分布式系统服务之间的幂等性
 
     浏览器发两次订单支付请求：
        1、单机用set去重
        2、多台机器之间怎么保证，这就是分布式系统的幂等性问题
           由于网络请求，浏览器发送第一次请求已经发了，但是由于网络原因一直没有响应，此时浏览器以为失败了就会再次发送一
           条请求，导致重复请求的问题。
        经验：
           1、用数据库的唯一键
           2、基于redis把order_id为key，set进去并置为一个状态，假如为已支付状态则不能再次set
             
 ### 分布式系统之间如何保证顺序性
 
     服务之间请求按照顺序执行
        1、可以基于dubbo的一致性hash策略模式,引入一个中间服务把order_id相同的请求按顺序分发到同一台服务A中，然后把请
           求按照一致性hash策略放到同一个队列中，即使是多线程也能保证只有一个线程执行。
        2、zookeeper分布式锁
             order_id+seq(序号)
             当执行的时候先拿到锁，然后看订单对应的序号，如果刚开始序号不是1那么就释放锁，下一个请求获取锁，意思就是根
             据序号来判定执行顺序。       
 
 ### 分布式锁
 
     redis分布式锁：
       1、普通实现：
          set orderId:1:lock 随机值 NX PX 30000
          释放锁通过lua脚本会判断一下orderId:1:lock及key的随机值，如果随机值不一致则不能删除
          问题：
             单机的话挂了就完了。
             主备也会存在分布式锁失败的问题（当master宕了还没来得及切换到slave就会导致事务不一致问题）
       2、RedLock算法
          redis cluster集群模式
          多个master分别获取锁，大多数node节点获取锁的时候才能针对某一个进行加锁，保证了即使宕机也会保证数据的一致性。
     zookeeper分布式锁：
          获取锁的时候就会创建临时节点，如果这个临时节点之前不存在那么就创建成功了，zookeeper保证只有一个人可以获取到
          同一把锁，其他机器尝试创建临时节点此时如果临时节点存在则创建失败，那么就会对那个临时节点注册一个监听器，如果
          这个临时节点的锁被释放了及第一个服务宕了此临时节点被zookeeper删除了，那么zookeeper就会通知此服务的然后此服
          务就会获取临时节点。
     对比：
        redis锁依赖与集群，每个一段时间尝试获取锁造成性能开销
        zookeeper是通过消息监听的方式，相对redis分布式锁要好
        
 ### 分布式session
 
     1、tomcat+redis
        在tomcat配置文件中配置RedisSessionHandlerValue、RedisSessionManager(host、port)也可以基于哨兵
        tomcat将数据放入redis中，其他tomcat服务服务从redis中读取到session中。
        问题：严重依赖web容器，重耦合
     2、spring session +redis
        不依赖于web容器，直接从spring session拿取数据到redis然后再通过redis获取session数据
 
 ### 分布式事务
 
     1、两阶段提交方案/XA方案
             事务管理器
                 1、询问
                 2、执行
             一个系统跨多个库
             spring+JTA
     2、TCC方案
             Try
             Confirm
             Cancel
             和业务耦合相关比较大，和钱打交道的用TCC,要么全部成功要么回滚。
     3、本地消息表
             国外ebay,大量依赖mysql的消息表
     4、可靠消息最终一致性方案
             结合阿里的RocketMQ支持分布式事务
             A系统已经入库操作此时发送confirm消息给MQ,MQ就会通知B系统消费这条消息去执行，如果B系统执行过程中
             失败了，那么就会失败重试或者，基于Zookeeper的分布式协调机制，zookeeper去通知A系统再此重发一条消
             息那么B系统怎么保证幂等性，可以在redis中记录一条表示，如果有表示说明已经处理过某个消息。
     5、最大努力通知方案
             系统A-----MQ------最大努力通知服务(失败重试)-----系统B
     实际上：做监控、日志、接口判断，因为分布式事务会导致代码很复杂、性能及吞吐量大幅度降级      
> reubenwang@foxmail.com
> 没事别找我，找我也不在！--我很忙🦆